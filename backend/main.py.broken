from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
import psycopg2
from psycopg2.extras import RealDictCursor
from datetime import datetime

app = FastAPI(title="HashBrotherhood API")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

def get_db():
    return psycopg2.connect(
        dbname="hashbrotherhood",
        user="u0_a307",
        host="localhost"
    )

@app.get("/")
async def root():
    return {
        "status": "online",
        "platform": "HashBrotherhood",
        "version": "1.0.0",
        "timestamp": datetime.now().isoformat()
    }

@app.get("/api/algorithms")
async def get_algorithms():
    conn = get_db()
    cursor = conn.cursor(cursor_factory=RealDictCursor)
    
    cursor.execute("""
        SELECT a.*, p.pool_host, p.pool_port
        FROM algorithms a
        LEFT JOIN pool_configs p ON a.id = p.algorithm_id
        WHERE a.active = TRUE
        ORDER BY a.id
    """)
    
    algorithms = cursor.fetchall()
    cursor.close()
    conn.close()
    
    return {"algorithms": algorithms}

@app.get("/api/algorithm/{name}")
async def get_algorithm(name: str):
    conn = get_db()
    cursor = conn.cursor(cursor_factory=RealDictCursor)
    
    cursor.execute("""
        SELECT a.*, p.pool_host, p.pool_port
        FROM algorithms a
        LEFT JOIN pool_configs p ON a.id = p.algorithm_id
        WHERE LOWER(a.name) = LOWER(%s) AND a.active = TRUE
    """, (name,))
    
    algo = cursor.fetchone()
    cursor.close()
    conn.close()
    
    if not algo:
        return {"error": "Algorithm not found"}
    
    return algo

@app.get("/api/miner/{wallet}/balance")
async def get_miner_balance(wallet: str):
    """Get miner's current balance and stats"""
    conn = get_db()
    cursor = conn.cursor(cursor_factory=RealDictCursor)
    
    cursor.execute("""
        SELECT 
            COALESCE(SUM(net_usdt_earned), 0) as balance,
            COUNT(*) as total_shares,
            MIN(timestamp) as first_share,
            MAX(timestamp) as last_share
        FROM revenue_snapshots
        WHERE miner_wallet = %s AND paid = FALSE
    """, (wallet,))
    
    balance_data = cursor.fetchone()
    
    cursor.execute("""
        SELECT COALESCE(SUM(amount_usdt), 0) as total_paid
        FROM payments
        WHERE miner_wallet = %s AND status = 'paid'
    """, (wallet,))
    
    paid_data = cursor.fetchone()
    
    cursor.close()
    conn.close()
    
    balance = float(balance_data['balance'] or 0)
    total_paid = float(paid_data['total_paid'] or 0)
    total_shares = balance_data['total_shares'] or 0
    
    if balance_data['last_share'] and balance_data['first_share']:
        time_diff = (balance_data['last_share'] - balance_data['first_share']).total_seconds()
        estimated_daily = balance * (86400 / max(time_diff, 1))
    else:
        estimated_daily = 0
    
    return {
        "wallet": wallet,
        "balance": round(balance, 8),
        "total_paid": round(total_paid, 2),
        "total_earned": round(balance + total_paid, 2),
        "total_shares": total_shares,
        "estimated_daily": round(estimated_daily, 4),
        "min_payout": 10.0,
        "network": "BEP20",
        "payout_progress": round((balance / 10.0) * 100, 1) if balance < 10 else 100.0
    }

@app.get("/api/payments/{wallet}")
async def get_payments(wallet: str):
    conn = get_db()
    cursor = conn.cursor(cursor_factory=RealDictCursor)
    
    cursor.execute("""
        SELECT id, amount_usdt, status, tx_hash, created_at, paid_at
        FROM payments
        WHERE miner_wallet = %s
        ORDER BY created_at DESC
        LIMIT 50
    """, (wallet,))
    
    payments = cursor.fetchall()
    cursor.close()
    conn.close()
    
    return {"payments": payments}

@app.get("/api/miner/{wallet}")
async def get_miner_stats(wallet: str):
    return {
        "wallet": wallet,
        "balance": 0.0,
        "hashrate": 0,
        "workers": 0,
        "estimated_daily": 0.0,
        "min_payout": 10.0,
        "network": "BEP20"
    }

@app.get("/health")
async def health_check():
    try:
        conn = get_db()
        cursor = conn.cursor()
        cursor.execute("SELECT 1")
        cursor.close()
        conn.close()
        return {"status": "healthy", "database": "connected"}
    except:
        return {"status": "unhealthy", "database": "disconnected"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)

@app.get("/api/hashrate/{wallet}")
async def get_miner_hashrate(wallet: str):
    """Calculate hashrate from recent shares"""
    conn = get_db()
    cursor = conn.cursor(cursor_factory=RealDictCursor)
    
    # Get shares from last 5 minutes
    cursor.execute("""
        SELECT difficulty, timestamp
        FROM revenue_snapshots
        WHERE miner_wallet = %s 
        AND timestamp > NOW() - INTERVAL '5 minutes'
        ORDER BY timestamp DESC
    """, (wallet,))
    
    shares = cursor.fetchall()
    cursor.close()
    conn.close()
    
    if not shares or len(shares) < 2:
        return {"wallet": wallet, "hashrate": 0, "unit": "H/s"}
    
    # Calculate average hashrate
    total_difficulty = sum(float(s['difficulty']) for s in shares)
    time_span = (shares[0]['timestamp'] - shares[-1]['timestamp']).total_seconds()
    
    if time_span > 0:
        hashrate = total_difficulty / time_span
    else:
        hashrate = 0
    
    return {
        "wallet": wallet,
        "hashrate": round(hashrate, 2),
        "unit": "H/s",
        "shares_count": len(shares)
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
