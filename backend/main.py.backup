from fastapi import FastAPI, WebSocket, WebSocketDisconnect, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Optional
import asyncio
import json
from datetime import datetime
import psycopg2
from psycopg2.extras import RealDictCursor

# FastAPI app
app = FastAPI(title="HashBrotherhood API")

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Database connection
def get_db_connection():
    return psycopg2.connect(
        dbname="hashbrotherhood",
        user="u0_a307",
        host="localhost"
    )

# Pydantic models
class Algorithm(BaseModel):
    id: int
    name: str
    stratum_port: int
    hardware_type: str
    hash_unit: str
    active: bool

class MinerStats(BaseModel):
    wallet: str
    balance: float
    hashrate: float
    workers: int
    estimated_daily: float

# WebSocket connection manager
class ConnectionManager:
    def __init__(self):
        self.active_connections: List[WebSocket] = []

    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)

    def disconnect(self, websocket: WebSocket):
        self.active_connections.remove(websocket)

    async def broadcast(self, message: str):
        for connection in self.active_connections:
            await connection.send_text(message)

manager = ConnectionManager()

# Routes
@app.get("/")
async def root():
    return {
        "status": "online",
        "platform": "HashBrotherhood",
        "version": "1.0.0",
        "timestamp": datetime.now().isoformat()
    }

@app.get("/api/algorithms")
async def get_algorithms():
    """Get all active algorithms"""
    conn = get_db_connection()
    cursor = conn.cursor(cursor_factory=RealDictCursor)
    
    cursor.execute("""
        SELECT a.*, p.pool_host, p.pool_port 
        FROM algorithms a
        LEFT JOIN pool_configs p ON a.id = p.algorithm_id
        WHERE a.active = true
    """)
    
    algorithms = cursor.fetchall()
    cursor.close()
    conn.close()
    
    return {"algorithms": algorithms}

@app.get("/api/algorithm/{algo_name}")
async def get_algorithm(algo_name: str):
    """Get specific algorithm details"""
    conn = get_db_connection()
    cursor = conn.cursor(cursor_factory=RealDictCursor)
    
    cursor.execute("""
        SELECT a.*, p.pool_host, p.pool_port, p.vardiff_min, p.vardiff_max
        FROM algorithms a
        LEFT JOIN pool_configs p ON a.id = p.algorithm_id
        WHERE a.name = %s AND a.active = true
    """, (algo_name,))
    
    algorithm = cursor.fetchone()
    cursor.close()
    conn.close()
    
    if not algorithm:
        raise HTTPException(status_code=404, detail="Algorithm not found")
    
    return algorithm

@app.get("/api/miner/{wallet}")
async def get_miner_stats(wallet: str):
    """Get miner statistics"""
    conn = get_db_connection()
    cursor = conn.cursor(cursor_factory=RealDictCursor)
    
    # Get total balance
    cursor.execute("""
        SELECT COALESCE(SUM(net_usdt_earned), 0) as balance
        FROM revenue_snapshots
        WHERE miner_wallet = %s AND paid = false
    """, (wallet,))
    
    result = cursor.fetchone()
    balance = float(result['balance']) if result else 0.0
    
    # Get recent hashrate (simulated for now)
    hashrate = 0.0
    workers = 0
    
    cursor.close()
    conn.close()
    
    return {
        "wallet": wallet,
        "balance": round(balance, 8),
        "hashrate": hashrate,
        "workers": workers,
        "estimated_daily": round(balance * 0.1, 8),  # Placeholder
        "min_payout": 10.0,
        "network": "BEP20"
    }

@app.get("/api/payments/{wallet}")
async def get_payments(wallet: str):
    """Get payment history for a wallet"""
    conn = get_db_connection()
    cursor = conn.cursor(cursor_factory=RealDictCursor)
    
    cursor.execute("""
        SELECT * FROM payments
        WHERE miner_wallet = %s
        ORDER BY created_at DESC
        LIMIT 50
    """, (wallet,))
    
    payments = cursor.fetchall()
    cursor.close()
    conn.close()
    
    return {"payments": payments}

@app.websocket("/ws/miner/{wallet}")
async def websocket_endpoint(websocket: WebSocket, wallet: str):
    """WebSocket for real-time miner stats"""
    await manager.connect(websocket)
    try:
        while True:
            # Send stats every 15 seconds
            conn = get_db_connection()
            cursor = conn.cursor(cursor_factory=RealDictCursor)
            
            cursor.execute("""
                SELECT COALESCE(SUM(net_usdt_earned), 0) as balance
                FROM revenue_snapshots
                WHERE miner_wallet = %s AND paid = false
            """, (wallet,))
            
            result = cursor.fetchone()
            balance = float(result['balance']) if result else 0.0
            
            cursor.close()
            conn.close()
            
            stats = {
                "wallet": wallet,
                "balance": round(balance, 8),
                "hashrate": 0.0,
                "workers": 0,
                "timestamp": datetime.now().isoformat()
            }
            
            await websocket.send_json(stats)
            await asyncio.sleep(15)
            
    except WebSocketDisconnect:
        manager.disconnect(websocket)

@app.get("/health")
async def health_check():
    """Health check endpoint"""
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT 1")
        cursor.close()
        conn.close()
        return {"status": "healthy", "database": "connected"}
    except Exception as e:
        return {"status": "unhealthy", "error": str(e)}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)

@app.get("/api/miner/{wallet}/balance")
async def get_miner_balance(wallet: str):
    """Get miner's current balance and stats"""
    conn = get_db()
    cursor = conn.cursor(cursor_factory=RealDictCursor)
    
    # Get total unpaid balance
    cursor.execute("""
        SELECT 
            COALESCE(SUM(net_usdt_earned), 0) as balance,
            COUNT(*) as total_shares,
            MIN(timestamp) as first_share,
            MAX(timestamp) as last_share
        FROM revenue_snapshots
        WHERE miner_wallet = %s AND paid = FALSE
    """, (wallet,))
    
    balance_data = cursor.fetchone()
    
    # Get total paid amount
    cursor.execute("""
        SELECT COALESCE(SUM(amount_usdt), 0) as total_paid
        FROM payments
        WHERE miner_wallet = %s AND status = 'paid'
    """, (wallet,))
    
    paid_data = cursor.fetchone()
    
    cursor.close()
    conn.close()
    
    # Calculate stats
    balance = float(balance_data['balance'] or 0)
    total_paid = float(paid_data['total_paid'] or 0)
    total_shares = balance_data['total_shares'] or 0
    
    # Estimated daily (based on last 24h)
    estimated_daily = balance * (86400 / max((balance_data['last_share'] - balance_data['first_share']).total_seconds(), 1)) if balance_data['last_share'] and balance_data['first_share'] else 0
    
    return {
        "wallet": wallet,
        "balance": round(balance, 8),
        "total_paid": round(total_paid, 2),
        "total_earned": round(balance + total_paid, 2),
        "total_shares": total_shares,
        "estimated_daily": round(estimated_daily, 4),
        "min_payout": 10.0,
        "network": "BEP20",
        "payout_progress": round((balance / 10.0) * 100, 1) if balance < 10 else 100.0
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
